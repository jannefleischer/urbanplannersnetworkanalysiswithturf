<!DOCTYPE html>
<html>
  <head>
    <title>OSM XML</title>
    <!--  <link rel="stylesheet" href="https://openlayers.org/en/v4.6.5/css/ol.css" type="text/css"> -->
    <link rel="stylesheet" href="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.1.3/css/ol.css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.4.3/proj4.js"></script>
    <!--  script src="https://openlayers.org/en/v4.6.5/build/ol-debug.js"></script> -->
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v5.1.3/build/ol.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
  </head>
  <body>
    <div id="map" class="map"></div>
    <script>
      var map;
      
//       var styles = {
//         'amenity': {
//           'parking': new ol.style.Style({
//             stroke: new ol.style.Stroke({
//               color: 'rgba(170, 170, 170, 1.0)',
//               width: 1
//             }),
//             fill: new ol.style.Fill({
//               color: 'rgba(170, 170, 170, 0.3)'
//             })
//           })
//         },
//         'building': {
//           '.*': new ol.style.Style({
//             zIndex: 100,
//             stroke: new ol.style.Stroke({
//               color: 'rgba(246, 99, 79, 1.0)',
//               width: 1
//             }),
//             fill: new ol.style.Fill({
//               color: 'rgba(246, 99, 79, 0.3)'
//             })
//           })
//         },
//         'highway': {
//           'service': new ol.style.Style({
//             stroke: new ol.style.Stroke({
//               color: 'rgba(255, 255, 255, 1.0)',
//               width: 2
//             })
//           }),
//           '.*': new ol.style.Style({
//             stroke: new ol.style.Stroke({
//               color: 'rgba(255, 255, 255, 1.0)',
//               width: 3
//             })
//           })
//         },
//         'landuse': {
//           'forest|grass|allotments': new ol.style.Style({
//             stroke: new ol.style.Stroke({
//               color: 'rgba(140, 208, 95, 1.0)',
//               width: 1
//             }),
//             fill: new ol.style.Fill({
//               color: 'rgba(140, 208, 95, 0.3)'
//             })
//           })
//         },
//         'natural': {
//           'tree': new ol.style.Style({
//             image: new ol.style.Circle({
//               radius: 2,
//               fill: new ol.style.Fill({
//                 color: 'rgba(140, 208, 95, 1.0)'
//               }),
//               stroke: null
//             })
//           })
//         }
//       };

// /*
// This has been generated by the overpass-turbo wizard.
// The original search was:
// “Straße”
// */
// [out:json][timeout:25];
// // gather results
// (
//   // query part for: “"Straße"”
//   way({{bbox}})[highway];
// );
// // print results
// out body;
// >;
// out skel qt;

	

//       var vector = new ol.layer.Vector({
//         source: vectorSource,
//         style: function(feature) {
//           for (var key in styles) {
//             var value = feature.get(key);
//             if (value !== undefined) {
//               for (var regexp in styles[key]) {
//                 if (new RegExp(regexp).test(value)) {
//                   return styles[key][regexp];
//                 }
//               }
//             }
//           }
//           return null;
//         }
//       });
        var utm32nName = 'urn:ogc:def:crs:EPSG::25832';
        proj4.defs(utm32nName, "+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs");
        ol.proj.proj4.register(proj4); //new on openlayers 5
        utm32n = ol.proj.get(utm32nName);
        
        function getIntersectionsWithTurf(olsource, mapinstance) {
        	var geojsonformat = new ol.format.GeoJSON()
//          wfsSourceFeaturesAsGeoJSON = geojsonformat.readFeatures(wfsSource);
	         feats = olsource.getFeatures();
	//          console.log(feats);
	         var intersections = [];
	         //TODO: Was mit geojson-rbush() machen
	         geojsonfeatsBase = geojsonfeatsSearch = geojsonformat.writeFeaturesObject(feats);
	//          console.log(geojsonfeatsSearch.features);
	
	         for (turfFeat1 of geojsonfeatsBase.features) {
	             geojsonaddList = [];
	             geojsondelList = [];
	             for (turfFeat2 of geojsonfeatsSearch.features) {
	//                  if (geojsonfeats.features[feat1]==geojsonfeats.features[feat2]) { continue; }
	                 if (turfFeat1==turfFeat2 || typeof turfFeat1 =='undefined' || typeof turfFeat2 =='undefined' ) { continue; }
	                 
	                 intersection = turf.lineIntersect(
	                 		turfFeat1,
	                 		turfFeat2
	                 );
	                 
	                 if ( intersection.features.length>0 ) {
	                     intersection.features[0].properties.id = turfFeat1.id + '@' + turfFeat2.id;
	                     intersection.features[0].properties.idFeat1 = turfFeat1.id;
	                     intersection.features[0].properties.idFeat2 = turfFeat2.id;
	//                      intersection.features[0].data = intersection.features[0].properties;
	//                      delete intersection.features[0].properties;
	//                      intersection.features[0].position = {
	//                          'x': intersection.features[0].geometry.coordinates[0],
	//                          'y': intersection.features[0].geometry.coordinates[1]
	//                      }
	//                      delete intersection.features[0].geometry;
	//                      if (intersection.features.length>1) { 
	//                          intersection.features[0].properties.morethenone = true;
	//                      }
	//                      intersections.push({
	//                          'baselineA': turfFeat1,
	//                          'baselineB': turfFeat2,
	//                          'point': intersection.features[0]
	//                      });
	                     intersections.push(intersection.features[0]);
	                 }
	                 
	             }
	//              if (geojsondelList.length>0) {
	//                  geojsonfeatsSearchReversed = geojsonfeatsSearch.features.slice().reverse();
	//                  geojsondelListReversed = geojsondelList.slice().reverse();
	//                  for (d of geojsondelListReversed) {
	//                      for (turfFeat2Compare in geojsonfeatsSearchReversed) {
	//                          if (d.id===geojsonfeatsSearchReversed[turfFeat2Compare].id) {
	//                              delete geojsonfeatsSearch.features[geojsonfeatsSearch.features.length-turfFeat2Compare]
	//                          }
	//                      }
	//                  }
	//                  for (d of geojsonaddList) {
	//                      geojsonfeatsSearch.features.push(d);
	//                  }
	//                  console.log('Current length: ' + Object.keys(geojsonfeatsSearch.features).length);
	//              }
	         }
	         for (i in intersections) {
	             a = intersections[i].properties.idFeat1;
	             b = intersections[i].properties.idFeat2;
	             intersectionsReversed = intersections.slice().reverse()
	             for (j in intersectionsReversed) {
	                 if (intersectionsReversed[j].properties.idFeat1==b && intersectionsReversed[j].properties.idFeat2==a) {
	//                      console.log('deleted: ' + intersections[intersectionsReversed.length-1-j].properties.id)
	//                      console.log('because of: ' + intersections[i].properties.id)
	                     intersections.splice(intersectionsReversed.length-1-j, 1);
	                 }
	             }
	         }
	         var intersectionsSource = new ol.source.Vector({
	             features: new ol.format.GeoJSON().readFeatures(turf.featureCollection(intersections))
	         })
	         
	         var insectionsLayer = new ol.layer.Vector({
	             source: intersectionsSource
	         })
	         
	         mapinstance.addLayer(insectionsLayer);
	         
	//          console.log('With new snipped lines: ' + Object.keys(geojsonfeatsSearch.features).length);
	//          console.log(geojsonfeatsSearch.features);
	         console.log('Intersections: ' + Object.keys(intersections).length);
	         console.log(intersections);
        }
        
		var extent;
        
        var osmSource = new ol.source.Vector({
		  format: new ol.format.OSMXML(),
		  loader: function(extent, resolution, projection) {
			    var epsg4326Extent =
			        ol.proj.transformExtent(extent, projection, 'EPSG:4326');
			    var client = new XMLHttpRequest();
			    client.open('POST', 'https://overpass-api.de/api/interpreter');
			    client.addEventListener('load', function() {
			      var features = new ol.format.OSMXML().readFeatures(client.responseText, {
			        featureProjection: map.getView().getProjection()
			      });
			      osmSource.addFeatures(features);
			      
			      getIntersectionsWithTurf(osmSource,map);
			      
			    });
			    var query = '[bbox:'+
			        epsg4326Extent[1] + ',' + epsg4326Extent[0] + ',' +
			        epsg4326Extent[3] + ',' + epsg4326Extent[2] + '];way[highway~"motorway|trunk|primary|secondary|tertiary|residential|unclassified|(motorway|trunk|primary|secondary|tertiary|residential)_link"];(._;>;);out skel qt;';
			    console.log('Query for Overpass-API: ' + query)
			    client.send(query);
		  },
		  strategy: ol.loadingstrategy.bbox
      	});
        
        var wfsSource = new ol.source.Vector({
	        format: new ol.format.WFS({gmlFormat: ol.format.GML3 }),
            attributions: 'Land NRW 2018 | <a href="https://www.govdata.de/dl-de/by-2-0">dl-de/by-2-0</a>',
	        loader: function(extent, resolution, projection) {
	            var epsg25832Extent = ol.proj.transformExtent(extent, 'EPSG:3857', 'urn:ogc:def:crs:EPSG::25832');
	            for (var i=0;i<epsg25832Extent.length;i++) {
	                epsg25832Extent[i]=parseInt(extent[i]);
	            }
	            var url = 'https://www.wfs.nrw.de/geobasis/wfs_nw_atkis-basis-dlm_aaa-modell-basiert?service=WFS&' +
	              'version=1.1.0&srsName=urn:ogc:def:crs:EPSG::25832&request=GetFeature&' +
	              'typeName=adv:AX_Strassenachse&' +
	              'bbox=' + epsg25832Extent.join(',') + ',urn:ogc:def:crs:EPSG::25832&fin=fin';
	            console.log(url);
	            $.ajax({
	              url
	            }).done(
                    function(response) {
                        //console.log(response);
                        wfsSource.addFeatures(new ol.format.WFS().readFeatures(response));
                    }
	            ).fail(
	                function(err, txtstatus) {
	                   console.log('something went wrong.')
                       console.log(err)
                       console.log(txtstatus)
	                }
	            );
	          },

	        strategy: ol.loadingstrategy.bbox
      });
      
      var osmvector = new ol.layer.Vector({
    	  source: osmSource,
    	  style: new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgba(255, 0, 0, 1.0)',
                lineDash: [10,10],
                width: 2
              })
    	  }),
          name: 'osmstreets'
      })
      
      var wfsvector = new ol.layer.Vector({
        source: wfsSource,
        style: new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: 'rgba(0, 0, 0, 1.0)',
            width: 2
          })
        }),
        name: 'basisdlm'
      });
      
      var raster = new ol.layer.Tile({
        source: new ol.source.OSM(),
        name: 'osmlayer'
      });
      
      fliederstrasse = [7.453175, 51.531939];
      fliederstrasseWebMercator = ol.proj.transform(ol.proj.fromLonLat(fliederstrasse), 'EPSG:3857', 'urn:ogc:def:crs:EPSG::25832');
      
      
      
      map = new ol.Map({
        layers: [
            raster,
            wfsvector,
            osmvector
        ],
        target: document.getElementById('map'),
        controls: ol.control.defaults({
          attributionOptions: {
            collapsible: false
          }
        }),
        view: new ol.View({
        	projection: 'urn:ogc:def:crs:EPSG::25832',
          center: fliederstrasseWebMercator,
          maxZoom: 19,
          zoom: 17
        })
      });
      
      //TODO: ol.interaction.select ergänzen um herauszufinden wie ich mit doubletten-Nodes umgehe. Select-Interaction so anlegen, dass sie genutzt werden kann um Service-Area-Startpunkte zu wählen.
      //TODO: Wie es scheint lädt Openlayers nur Objekte nach, die nicht schon bereits auf der Karte sind, d.h. ich sollte die Berechnung von Schnittpunkten nur auf dem neuen Datensatz (und dessen Enden) berechnen und nicht für das komplette Layer
      //TODO: Lösung finden wie doppelte Nodes informationen zu allen Anlieger-Edges bekommen (vermutlich: Edges bekommen informationen zu den vereinzelten Nodes...)
      //TODO: Cytoscape.js hinzuladen 
      //TODO: Eine Strategie entwickeln, wie aus geladenen Edges (also Straßen mit deren Länge als Kosten) die dazugehörigen Nodes (ohne doubletten) ermittelt und an cytoscape übergeben werden können.
      //TODO: Den kompletten Graph in Cytoscape.js aufbauen
      
      
    </script>
  </body>
</html>